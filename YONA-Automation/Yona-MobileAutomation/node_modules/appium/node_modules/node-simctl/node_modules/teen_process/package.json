{
  "name": "teen_process",
  "description": "A grown up version of Node's spawn/exec",
  "keywords": [
    "child_process",
    "process management"
  ],
  "version": "1.3.1",
  "author": {
    "name": "appium"
  },
  "license": "Apache License 2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/appium/node-teen_process.git"
  },
  "bugs": {
    "url": "https://github.com/appium/node-teen_process/issues"
  },
  "engines": [
    "node"
  ],
  "main": "./build/index.js",
  "bin": {},
  "directories": {
    "lib": "lib"
  },
  "dependencies": {
    "babel-runtime": "=5.5.5",
    "bluebird": "^2.9.25",
    "shell-quote": "^1.4.3",
    "source-map-support": "^0.2.10",
    "through": "^2.3.7"
  },
  "scripts": {
    "prepublish": "gulp prepublish",
    "test": "gulp once",
    "watch": "gulp"
  },
  "devDependencies": {
    "appium-gulp-plugins": "^1.1.0",
    "chai": "^2.2.0",
    "chai-as-promised": "^5.0.0",
    "gulp": "^3.8.11",
    "mochawait": "^2.0.0",
    "yargs": "^3.8.0"
  },
  "readme": "node-teen_process\n=================\n\nA grown-up version of Node's child_process. `exec` is really useful, but it\nsuffers many limitations. This is an es7 (`async`/`await`) implementation of\n`exec` that uses `spawn` under the hood. It takes care of wrapping commands and\narguments so we don't have to care about escaping spaces. It can also return\nstdout/stderr even when the command fails, or times out. Importantly, it's also\nnot susceptible to max buffer issues.\n\n### teen_process.exec\n\nExamples:\n\n```js\nimport { exec } from 'teen_process';\n\n// basic usage\nlet {stdout, stderr, code} = await exec('ls', ['/usr/local/bin']);\nconsole.log(stdout.split(\"\\n\"));  // array of files\nconsole.log(stderr);              // ''\nconsole.log(code);                // 0\n\n// works with spaces\nawait exec('/command/with spaces.sh', ['foo', 'argument with spaces'])\n// as though we had run: \"/command/with spaces.sh\" foo \"argument with spaces\"\n\n// nice error handling that still includes stderr/stdout/code\ntry {\n  await exec('echo_and_exit', ['foo', '10']);\n} catch (e) {\n  console.log(e.message);  // \"Exited with code 10\"\n  console.log(e.stdout);   // \"foo\"\n  console.log(e.code);     // 10\n}\n```\n\nThe `exec` function takes some options, with these defaults:\n\n```js\n{\n  cwd: undefined,\n  env: process.env,\n  timeout: null,\n  killSignal: 'SIGTERM',\n  encoding: 'utf8',\n  ignoreOutput: false\n}\n```\n\nMost of these are self-explanatory. `ignoreOutput` is useful if you have a very\nchatty process whose output you don't care about and don't want to add it to\nthe memory consumed by your program.\n\nExample:\n\n```js\ntry {\n  await exec('sleep', ['10'], {timeout: 500, killSignal: 'SIGINT'});\n} catch (e) {\n  console.log(e.message);  // \"'sleep 10' timed out after 500ms\"\n}\n```\n\n### teen_process.SubProcess\n\n`spawn` is already pretty great but for some uses there's a fair amount of\nboilerplate, especially when using in an `async/await` context. `teen_process`\nalso exposes a `SubProcess` class, which can be used to cut down on some\nboilerplate. It has 2 methods, `start` and `stop`:\n\n```js\nimport { SubProcess } from 'teen_process';\n\nasync function tailFileForABit () {\n  let proc = new SubProcess('tail', ['-f', '/var/log/foo.log']);\n  await proc.start();\n  await proc.stop();\n}\n```\n\nErrors with start/stop are thrown in the calling context.\n\nYou can listen to 4 events, `output`, `exit`, `lines-stdout`, and\n`lines-stderr`:\n\n```js\nproc.on('output', (stdout, stderr) => {\n  console.log(`stdout: ${stdout}`);\n  console.log(`stderr: ${stderr}`);\n});\n\nproc.on('exit', (code, signal) => {\n  console.log(`exited with code ${code} from signal ${signal}`);\n  // exited with code 127 from signal SIGHUP\n});\n\n// lines-stderr is just the same\nproc.on('lines-stdout', lines => {\n  console.log(lines);\n  // ['foo', 'bar', 'baz']\n  // automatically handles rejoining lines across stream chunks\n});\n```\n\nHow does `SubProcess` know when to return control from `start()`? Well, the\ndefault is to wait until there is some output. You can also pass in a number,\nwhich will cause it to wait for that number of ms, or a function (which I call\na `startDetector`) which takes stdout and stderr and returns true when you want\ncontrol back. Examples:\n\n```js\nawait proc.start(); // will continue when stdout or stderr has received data\nawait proc.start(0); // will continue immediately\n\nlet sd = (stdout, stderr) => {\n  return stderr.indexOf('blarg') !== -1;\n};\nawait proc.start(sd); // will continue when stderr receives 'blarg'\n```\n\nA custom `startDetector` can also throw an error if it wants to declare the\nstart unsuccessful. For example, if we know that the first output might contain\na string which invalidates the process (for us), we could define a custom\n`startDetector` as follows:\n\n```js\nlet sd = (stdout, stderr) => {\n  if (/fail/.test(stderr)) {\n    throw new Error(\"Encountered failure condition\");\n  }\n  return stdout || stderr;\n};\nawait proc.start(sd); // will continue when output is received that doesn't\n                      // match 'fail'\n```\n\nFinally, if you want to specify a maximum time to wait for a process to start,\nyou can do that by passing a second parameter in milliseconds to `start()`:\n\n```js\n// use the default startDetector and throw an error if we wait for more than\n// 1000ms for output\nawait proc.start(null, 1000);\n```\n\nAnd how about killing the processes? Can you provide a custom signal, instead\nof using the default `SIGTERM`? Why yes:\n\n```js\nawait proc.stop('SIGHUP');\n```\n\nIf your process might not be killable and you don't really care, you can also\npass a timeout, which will return control to you in the form of an error after\nthe timeout has passed:\n\n```js\ntry {\n  await proc.stop('SIGHUP', 1000);\n} catch (e) {\n  console.log(\"Proc failed to stop, ignoring cause YOLO\");\n}\n```\n\nAll in all, this makes it super simple to, say, write a script that tails\na file for X seconds, using async/await and pretty straightforward error\nhandling.\n\n```js\nasync function boredTail (filePath, boredAfter = 10000) {\n  let p = new SubProcess('tail', ['-f', filePath]);\n  p.on('output', stdout => {\n    if (stdout) {\n      console.log(`STDOUT: ${stdout.trim()}`);\n    }\n  });\n  await p.start();\n  await Bluebird.delay(boredAfter);\n  await p.stop();\n}\n```\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/appium/node-teen_process",
  "_id": "teen_process@1.3.1",
  "_shasum": "4a2d0ee6f0fd1639e2c3867ba4a7a9f32886b223",
  "_resolved": "https://registry.npmjs.org/teen_process/-/teen_process-1.3.1.tgz",
  "_from": "https://registry.npmjs.org/teen_process/-/teen_process-1.3.1.tgz"
}
